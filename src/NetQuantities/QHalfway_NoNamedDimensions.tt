<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
var dimensions = new DimensionInfo[]{
    new(
        L: -2, M: 0, T: 0, I: 0, Th: 0, N: 0, J: 0,
        new (string, string, string)[] {
            ("this", "QLength", "QSpatialFrequency"),
        }),
    new(
        L: 0, M: -1, T: 0, I: 0, Th: 0, N: 0, J: 0,
        new (string, string, string)[] {
            ("this", "QMass", "QDimensionless"),
        }),
    new(
        L: 1, M: 1, T: 0, I: 0, Th: 0, N: 0, J: 0,
        new (string, string, string)[] {
            ("QLength", "QMass", "this"),
            ("QMomentum", "QTime", "this"),
        }),
    /*
    new(
        L: 0, M: 0, T: 0, I: 0, Th: 0, N: 0, J: 0,
        new (string, string, string)[] {
        }),
    */
};
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System;
using System.Collections.Generic;
using System.Text;

namespace NetQuantities;

<#  foreach(var dim in dimensions) { #>

/// <summary>
/// Calculation halfway type that represents [<#=dim.Comment#>] dimension.
/// This type is intended to be used only during conversion to other types,
/// therefore it is defined as ref struct type.
/// </summary>
[<#=dim.QuantityAttribute#>]
<#      foreach(var attr in dim.QuantityOperationAttributes) { #>
[<#=attr#>]
<#      } #>
public readonly ref partial struct <#=dim.TypeName#>
{
}

<# } #>

<#+
public class DimensionInfo
{
    public int L { get; }
    public int M { get; }
    public int T { get; }
    public int I { get; }
    public int Th { get; }
    public int N { get; }
    public int J { get; }
    public IReadOnlyList<(string Multiplicant, string Multiplier, string Product)> Operations { get; }

    public string Comment
    {
        get
        {
            var list = new List<string>();
            if(L  != 0) { list.Add($"L^{ L }"); }
            if(M  != 0) { list.Add($"M^{ M }"); }
            if(T  != 0) { list.Add($"T^{ T }"); }
            if(I  != 0) { list.Add($"I^{ I }"); }
            if(Th != 0) { list.Add($"Th^{Th}"); }
            if(N  != 0) { list.Add($"N^{ N }"); }
            if(J  != 0) { list.Add($"J^{ J }"); }
            return list.Count > 0 ? string.Join(" * ", list) : "1";
        }
    }

    public string QuantityAttribute
        => $"Quantity(L: {L}, M: {M}, T: {T}, I: {I}, Th: {Th}, N: {N}, J: {J})";

    public IEnumerable<string> QuantityOperationAttributes
    {
        get
        {
            string getType(string name)
            {
                const string pattern
                    = @"(?:^\s*L\s*=\s*(?<L>[+\-]?\d+))?"
                    + @"(?:(?:^|\s*,)\s*M\s*=\s*(?<M>[+\-]?\d+))?"
                    + @"(?:(?:^|\s*,)\s*T\s*=\s*(?<T>[+\-]?\d+))?"
                    + @"(?:(?:^|\s*,)\s*I\s*=\s*(?<I>[+\-]?\d+))?"
                    + @"(?:(?:^|\s*,)\s*Th\s*=\s*(?<Th>[+\-]?\d+))?"
                    + @"(?:(?:^|\s*,)\s*N\s*=\s*(?<N>[+\-]?\d+))?"
                    + @"(?:(?:^|\s*,)\s*J\s*=\s*(?<J>[+\-]?\d+))?";

                var matched = Regex.Match(name, pattern);
                if(matched.Success && !string.IsNullOrWhiteSpace(matched.Value))
                {
                    return "typeof(" + GetTypeName(
                        l : int.TryParse(matched.Groups["L" ].Value, out var l ) ? l  : 0,
                        m : int.TryParse(matched.Groups["M" ].Value, out var m ) ? m  : 0,
                        t : int.TryParse(matched.Groups["T" ].Value, out var t ) ? t  : 0,
                        i : int.TryParse(matched.Groups["I" ].Value, out var i ) ? i  : 0,
                        th: int.TryParse(matched.Groups["Th"].Value, out var th) ? th : 0,
                        n : int.TryParse(matched.Groups["N" ].Value, out var n ) ? n  : 0,
                        j : int.TryParse(matched.Groups["J" ].Value, out var j ) ? j  : 0)
                        + ")";
                }
                return name == "this"
                ? $"typeof({TypeName})"
                : $"typeof({name})";
            }

            foreach(var op in Operations)
            {
                yield return $"QuantityOperation({getType(op.Multiplicant)}, {getType(op.Multiplier)}, {getType(op.Product)})";
            }
            yield break;
        }
    }

    public string TypeName
        => GetTypeName(L, M, T, I, Th, N, J);
    private static string GetTypeName(int l, int m, int t, int i, int th, int n, int j)
    {
        static string num(int value) => value >= 0 ? $"{value}" : $"m{-value}";

        return $"QHalfway_L{num(l)}_M{num(m)}_T{num(t)}_I{num(i)}_Th{num(th)}_N{num(n)}_J{num(j)}";
    }


    public DimensionInfo(
        int L ,
        int M ,
        int T ,
        int I ,
        int Th,
        int N ,
        int J ,
        params (string Multiplicant, string Multiplier, string Product)[] Operations)
    {
        this.L  = L ;
        this.M  = M ;
        this.T  = T ;
        this.I  = I ;
        this.Th = Th;
        this.N  = N ;
        this.J  = J ;
        this.Operations = Operations;
    }
}

#>